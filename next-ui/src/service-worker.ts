/**
 * Service Worker
 * 
 * Handles caching strategy for offline support and performance optimization.
 * Key features:
 * - Pre-cache critical assets (icons, fonts, stylesheets)
 * - Runtime caching for API responses
 * - Offline fallback
 * - Cache versioning and cleanup
 */

/// <reference lib="webworker" />

declare const self: ServiceWorkerGlobalScope & {
    __WB_MANIFEST: Array<{ url: string; revision: string | null }>;
};

import { precacheAndRoute, cleanupOutdatedCaches } from 'workbox-precaching';
import { registerRoute } from 'workbox-routing';
import { CacheFirst, NetworkFirst, StaleWhileRevalidate } from 'workbox-strategies';
import { ExpirationPlugin } from 'workbox-expiration';
import { CacheableResponsePlugin } from 'workbox-cacheable-response';

// Clean up old caches from previous versions
cleanupOutdatedCaches();

// Precache all assets generated by Vite build
// The manifest is injected by vite-plugin-pwa during build
const manifest = self.__WB_MANIFEST || [];
precacheAndRoute(manifest);

// Cache strategy for icon sprite and static images
registerRoute(
    ({ request, url }: { request: Request; url: URL }) => {
        return (
            request.destination === 'image' ||
            url.pathname.includes('/icon-sprite.svg') ||
            url.pathname.includes('/assets/Logo.png')
        );
    },
    new CacheFirst({
        cacheName: 'images-cache',
        plugins: [
            new CacheableResponsePlugin({
                statuses: [0, 200]
            }),
            new ExpirationPlugin({
                maxEntries: 60,
                maxAgeSeconds: 30 * 24 * 60 * 60 // 30 days
            })
        ]
    })
);

// Cache strategy for fonts
registerRoute(
    ({ request }: { request: Request }) => request.destination === 'font',
    new CacheFirst({
        cacheName: 'fonts-cache',
        plugins: [
            new CacheableResponsePlugin({
                statuses: [0, 200]
            }),
            new ExpirationPlugin({
                maxEntries: 30,
                maxAgeSeconds: 365 * 24 * 60 * 60 // 1 year
            })
        ]
    })
);

// Cache strategy for stylesheets
registerRoute(
    ({ request }: { request: Request }) => request.destination === 'style',
    new StaleWhileRevalidate({
        cacheName: 'css-cache',
        plugins: [
            new CacheableResponsePlugin({
                statuses: [0, 200]
            }),
            new ExpirationPlugin({
                maxEntries: 20,
                maxAgeSeconds: 7 * 24 * 60 * 60 // 7 days
            })
        ]
    })
);

// Cache strategy for scripts
registerRoute(
    ({ request }: { request: Request }) => request.destination === 'script',
    new StaleWhileRevalidate({
        cacheName: 'js-cache',
        plugins: [
            new CacheableResponsePlugin({
                statuses: [0, 200]
            }),
            new ExpirationPlugin({
                maxEntries: 30,
                maxAgeSeconds: 7 * 24 * 60 * 60 // 7 days
            })
        ]
    })
);

// Cache strategy for API calls - Network First with fallback
registerRoute(
    ({ url }: { url: URL }) => url.pathname.startsWith('/api/'),
    new NetworkFirst({
        cacheName: 'api-cache',
        plugins: [
            new CacheableResponsePlugin({
                statuses: [0, 200]
            }),
            new ExpirationPlugin({
                maxEntries: 50,
                maxAgeSeconds: 5 * 60 // 5 minutes
            })
        ],
        networkTimeoutSeconds: 10
    })
);

// Cache strategy for build info (rarely changes)
registerRoute(
    ({ url }: { url: URL }) => url.pathname === '/api/build-info',
    new StaleWhileRevalidate({
        cacheName: 'build-info-cache',
        plugins: [
            new CacheableResponsePlugin({
                statuses: [0, 200]
            }),
            new ExpirationPlugin({
                maxEntries: 1,
                maxAgeSeconds: 24 * 60 * 60 // 24 hours
            })
        ]
    })
);

// Listen for messages from the app
self.addEventListener('message', (event) => {
    if (event.data && event.data.type === 'SKIP_WAITING') {
        self.skipWaiting();
    }

    if (event.data && event.data.type === 'CLEAR_CACHE') {
        // Clear all caches
        caches.keys().then((cacheNames) => {
            return Promise.all(
                cacheNames.map((cacheName) => caches.delete(cacheName))
            );
        });
    }
});

// Activate event - claim clients immediately
self.addEventListener('activate', (event) => {
    event.waitUntil(self.clients.claim());
});

console.log('Service Worker: Registered and active');
